/* tslint:disable */
/* eslint-disable */
/**
 * Vulcan API
 * Public API for Vulcan Vulnerability Scan Engine
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Asset,
    AssetFromJSON,
    AssetToJSON,
    AssetUpdatePayload,
    AssetUpdatePayloadFromJSON,
    AssetUpdatePayloadToJSON,
    Assetresponse,
    AssetresponseFromJSON,
    AssetresponseToJSON,
    CreateAssetPayload,
    CreateAssetPayloadFromJSON,
    CreateAssetPayloadToJSON,
    Listassetentry,
    ListassetentryFromJSON,
    ListassetentryToJSON,
} from '../models';

export interface AssetsCreateRequest {
    teamId: string;
    payload: CreateAssetPayload;
}

export interface AssetsCreateMultiStatusRequest {
    teamId: string;
    payload: CreateAssetPayload;
}

export interface AssetsDeleteRequest {
    assetId: string;
    teamId: string;
}

export interface AssetsListRequest {
    teamId: string;
}

export interface AssetsShowRequest {
    assetId: string;
    teamId: string;
}

export interface AssetsUpdateRequest {
    assetId: string;
    teamId: string;
    payload: AssetUpdatePayload;
}

/**
 * 
 */
export class AssetsApi extends runtime.BaseAPI {

    /**
     * Creates assets in bulk mode.    This operation accepts an array of assets and an optional array of group identifiers, and returns an array of successfully created assets.    If no groups are specified, assets will be added to the team\'s Default group.    If one of the specified assets already exists for the team but is currently not associated with the requested groups, the association is created.    If for any reason, the creation of an asset fails, an error message will be returned referencing the failed asset and the entire operation will be rolled back.    ---    Valid asset types:    - AWSAccount    - DomainName    - Hostname    - IP    - IPRange    - DockerImage    - WebAddress    - GitRepository    ---    If the asset type is informed, then Vulcan will use that value to create the new asset.    Otherwise, Vulcan will try to automatically discover the asset type.    Notice that this may result in Vulcan creating more than one asset.    For instance, an user trying to create an asset for \"vulcan.example.com\", without specifying the asset type, will end up with two assets created:    - vulcan.example.com (DomainName) and    - vulcan.example.com (Hostname).
     * create assets
     */
    async assetsCreateRaw(requestParameters: AssetsCreateRequest): Promise<runtime.ApiResponse<Array<Asset>>> {
        if (requestParameters.teamId === null || requestParameters.teamId === undefined) {
            throw new runtime.RequiredError('teamId','Required parameter requestParameters.teamId was null or undefined when calling assetsCreate.');
        }

        if (requestParameters.payload === null || requestParameters.payload === undefined) {
            throw new runtime.RequiredError('payload','Required parameter requestParameters.payload was null or undefined when calling assetsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/teams/{team_id}/assets`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters.teamId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAssetPayloadToJSON(requestParameters.payload),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AssetFromJSON));
    }

    /**
     * Creates assets in bulk mode.    This operation accepts an array of assets and an optional array of group identifiers, and returns an array of successfully created assets.    If no groups are specified, assets will be added to the team\'s Default group.    If one of the specified assets already exists for the team but is currently not associated with the requested groups, the association is created.    If for any reason, the creation of an asset fails, an error message will be returned referencing the failed asset and the entire operation will be rolled back.    ---    Valid asset types:    - AWSAccount    - DomainName    - Hostname    - IP    - IPRange    - DockerImage    - WebAddress    - GitRepository    ---    If the asset type is informed, then Vulcan will use that value to create the new asset.    Otherwise, Vulcan will try to automatically discover the asset type.    Notice that this may result in Vulcan creating more than one asset.    For instance, an user trying to create an asset for \"vulcan.example.com\", without specifying the asset type, will end up with two assets created:    - vulcan.example.com (DomainName) and    - vulcan.example.com (Hostname).
     * create assets
     */
    async assetsCreate(requestParameters: AssetsCreateRequest): Promise<Array<Asset>> {
        const response = await this.assetsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates assets in bulk mode (MultiStatus).    This operation is similar to the \"Create Assets in Bulk Mode\", with 2 main differences:    - This endpoint is not atomic. Each asset creation request will succeed or fail indenpendently of the other requests.    - This endpoint will return an array of AssetResponse in the following way:     · For each asset with specified type, returns an AssetResponse indicating the success or failure for its creation.     · For each asset with no type specified and successfully created, returns one AssetResponse for each auto detected asset.     · For each asset with no type specified which its creation produced an error, returns one AssetResponse indicating the failure for the creation of its detected assets without specifying which exact type failed.    In the case of all assets being successfully created, this endpoint will return status code 201-Created.     Otherwise, it will return a 207-MultiStatus code, indicating that at least one of the requested operations failed.    
     * createMultiStatus assets
     */
    async assetsCreateMultiStatusRaw(requestParameters: AssetsCreateMultiStatusRequest): Promise<runtime.ApiResponse<Array<Assetresponse>>> {
        if (requestParameters.teamId === null || requestParameters.teamId === undefined) {
            throw new runtime.RequiredError('teamId','Required parameter requestParameters.teamId was null or undefined when calling assetsCreateMultiStatus.');
        }

        if (requestParameters.payload === null || requestParameters.payload === undefined) {
            throw new runtime.RequiredError('payload','Required parameter requestParameters.payload was null or undefined when calling assetsCreateMultiStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/teams/{team_id}/assets/multistatus`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters.teamId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAssetPayloadToJSON(requestParameters.payload),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AssetresponseFromJSON));
    }

    /**
     * Creates assets in bulk mode (MultiStatus).    This operation is similar to the \"Create Assets in Bulk Mode\", with 2 main differences:    - This endpoint is not atomic. Each asset creation request will succeed or fail indenpendently of the other requests.    - This endpoint will return an array of AssetResponse in the following way:     · For each asset with specified type, returns an AssetResponse indicating the success or failure for its creation.     · For each asset with no type specified and successfully created, returns one AssetResponse for each auto detected asset.     · For each asset with no type specified which its creation produced an error, returns one AssetResponse indicating the failure for the creation of its detected assets without specifying which exact type failed.    In the case of all assets being successfully created, this endpoint will return status code 201-Created.     Otherwise, it will return a 207-MultiStatus code, indicating that at least one of the requested operations failed.    
     * createMultiStatus assets
     */
    async assetsCreateMultiStatus(requestParameters: AssetsCreateMultiStatusRequest): Promise<Array<Assetresponse>> {
        const response = await this.assetsCreateMultiStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete an asset.
     * delete assets
     */
    async assetsDeleteRaw(requestParameters: AssetsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.assetId === null || requestParameters.assetId === undefined) {
            throw new runtime.RequiredError('assetId','Required parameter requestParameters.assetId was null or undefined when calling assetsDelete.');
        }

        if (requestParameters.teamId === null || requestParameters.teamId === undefined) {
            throw new runtime.RequiredError('teamId','Required parameter requestParameters.teamId was null or undefined when calling assetsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/teams/{team_id}/assets/{asset_id}`.replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters.assetId))).replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters.teamId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an asset.
     * delete assets
     */
    async assetsDelete(requestParameters: AssetsDeleteRequest): Promise<void> {
        await this.assetsDeleteRaw(requestParameters);
    }

    /**
     * List all assets from a team.
     * list assets
     */
    async assetsListRaw(requestParameters: AssetsListRequest): Promise<runtime.ApiResponse<Array<Listassetentry>>> {
        if (requestParameters.teamId === null || requestParameters.teamId === undefined) {
            throw new runtime.RequiredError('teamId','Required parameter requestParameters.teamId was null or undefined when calling assetsList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/teams/{team_id}/assets`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters.teamId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ListassetentryFromJSON));
    }

    /**
     * List all assets from a team.
     * list assets
     */
    async assetsList(requestParameters: AssetsListRequest): Promise<Array<Listassetentry>> {
        const response = await this.assetsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Describe an asset.
     * show assets
     */
    async assetsShowRaw(requestParameters: AssetsShowRequest): Promise<runtime.ApiResponse<Asset>> {
        if (requestParameters.assetId === null || requestParameters.assetId === undefined) {
            throw new runtime.RequiredError('assetId','Required parameter requestParameters.assetId was null or undefined when calling assetsShow.');
        }

        if (requestParameters.teamId === null || requestParameters.teamId === undefined) {
            throw new runtime.RequiredError('teamId','Required parameter requestParameters.teamId was null or undefined when calling assetsShow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/teams/{team_id}/assets/{asset_id}`.replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters.assetId))).replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters.teamId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
    }

    /**
     * Describe an asset.
     * show assets
     */
    async assetsShow(requestParameters: AssetsShowRequest): Promise<Asset> {
        const response = await this.assetsShowRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update an asset.
     * update assets
     */
    async assetsUpdateRaw(requestParameters: AssetsUpdateRequest): Promise<runtime.ApiResponse<Asset>> {
        if (requestParameters.assetId === null || requestParameters.assetId === undefined) {
            throw new runtime.RequiredError('assetId','Required parameter requestParameters.assetId was null or undefined when calling assetsUpdate.');
        }

        if (requestParameters.teamId === null || requestParameters.teamId === undefined) {
            throw new runtime.RequiredError('teamId','Required parameter requestParameters.teamId was null or undefined when calling assetsUpdate.');
        }

        if (requestParameters.payload === null || requestParameters.payload === undefined) {
            throw new runtime.RequiredError('payload','Required parameter requestParameters.payload was null or undefined when calling assetsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/teams/{team_id}/assets/{asset_id}`.replace(`{${"asset_id"}}`, encodeURIComponent(String(requestParameters.assetId))).replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters.teamId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AssetUpdatePayloadToJSON(requestParameters.payload),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
    }

    /**
     * Update an asset.
     * update assets
     */
    async assetsUpdate(requestParameters: AssetsUpdateRequest): Promise<Asset> {
        const response = await this.assetsUpdateRaw(requestParameters);
        return await response.value();
    }

}
